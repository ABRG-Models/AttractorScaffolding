# Simulation code

This directory contains the most important simulation code. The key
files to look at, when referring to the paper are the header files,
and the program **evolve.cpp** which reproduces the result in the
paper. Other results in the paper are generated by **proprandomfits.cpp**.

## Headers

The code is stored in the following headers, in sim/include/:

### lib.h

Contains most of the functionality of the system, several global
variables, functions that set up masks, define the types used in the
program. Important functions such as random_genome(), zero_genome,
copy_genome() and evolve_genome() are found here.

### fitness.h and fitness4.h

This header includes the relevant fitness function based on #defines
set at compile time. The paper is based on fitness4.h, which contains
the function evaluate_fitness(). Other fitness functions have been
investigated and these are also present (fitness[1-8].h)

### basins.h

This header contains code to determine the transitions in all of the
basins of attraction found for a given genome. Contains the class
BasinOfAttraction and a function find_basins_of_attraction() which
finds all the basins for a given genome.

### endpoint.h

Contains a little code that is included both by fitness.h and by
basins.h.

### mutation.h

Contains functions to determine the number of fit mutated genomes that
exist * a Hamming distance m (or h) away from a given, fit
genome. Also contains the function evolve_new_genome, which, starting
from a random_genome, calls evolve_genome() until f=1.

### quine.h

Complexity analysis code. Quine-McCluskey method.

## Simulation programs

Each of the .cpp files is compiled into a separate program (or
sometimes, into several related programs, with different #defines for
each compilation).

The programs are:

### evolve.cpp

The main algorithm reported in the paper.

Evolves genomes by flipping bits with a probability supplied at the
command line and accepting changes if the evolved genome specifies a
network whose fitness has stayed the same or increased (_nodrift
binaries are those for which the fitness *must increase* if the
mutation is to be accepted).

* Compiles to **evolve** and **evolve_nodrift**
* Results into: data/evolve_ia1_ip0_a21_p10_ff4*.csv or data/evolve_nodrift_ia1_ip0_a21_p10_ff4*.csv
* Results plotted with plot_evospeed.py, plot_evospeed_histo_only_multi.py and plot_evospeed_powerlaw.py

### evolve_fit_genome.cpp

Starting from a random genome, evolve it for as many generations as
necessary to to find an f=1 genome, then show the resulting fit genome
on stdout and exit.

* Compiles to **evolve_fit_genome**
* Results on command line.

### evolve_onegen.cpp

Run a single evolution step, showing the genome before and after.

* Compiles to **evolve_onegen**
* Results on command line.

### proprandomfits.cpp

Compute the proportion of random genomes that have f=1. Find the
proportion of fit genomes by randomly sampling the genome space OR by
an exhaustive search in the cases where this is computationally
feasible. The result of this program is part of the main paper text
(for the n=3 exhaustive search).

* Compiles into **proprandom3**, **proprandom4**, **proprandom5**, **proprandom6**
* Results on command line.

### complexity_random.cpp

Generates 10000 random genomes, and computes the complexity
(Quine-McCluskey), the canalyzingness, the bias and information about
the number of basins of attraction in the state space defined by each
genome.

* Compiles into complexity_random
* Results in data/complexity_random.csv

### complexity_fit.cpp

Generates 10000 f=1 genomes, and computes the complexity
(Quine-McCluskey), the canalyzingness, the bias and information about
the number of basins of attraction in the state space defined by each
genome.

* Compiles into complexity_fit
* Results in data/complexity_fit.csv

### showselected.cpp

Show the "selected genome" - the one that is used for Fig 1 of the
associated paper.

* Compiles into **showselected**
* Results on command line.
